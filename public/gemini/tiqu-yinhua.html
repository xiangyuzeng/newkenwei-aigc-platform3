<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°èŠ±å›¾æ¡ˆæ™ºèƒ½æå–</title>
    <link rel="stylesheet" href="../styles/workspace.css">
    <link rel="stylesheet" href="../styles/mobile.css">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif; background: #f5f7fa; min-height: 100vh; color: #1e293b; }

        /* é¡¶éƒ¨å¯¼èˆª */
        .top-header { background: #fff; padding: 12px 24px; display: flex; align-items: center; justify-content: space-between; position: fixed; top: 0; left: 0; right: 0; z-index: 100; height: 56px; }
        .header-left { display: flex; align-items: center; gap: 16px; }
        .header-btn { display: flex; align-items: center; gap: 6px; padding: 8px 16px; background: #f8f9fb; border: 1px solid #e8ecf1; border-radius: 8px; font-size: 13px; color: #475569; cursor: pointer; transition: all 0.2s; text-decoration: none; }
        .header-btn:hover { background: #f0f2f5; border-color: #d1d5db; }
        .page-title { font-size: 20px; font-weight: 600; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); -webkit-background-clip: text; background-clip: text; color: transparent; }
        .header-right { display: flex; align-items: center; gap: 12px; }
        .header-icon-btn { width: 36px; height: 36px; border-radius: 8px; border: 1px solid #e8ecf1; background: #fff; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 16px; color: #64748b; }

        /* åŠŸèƒ½æ ‡ç­¾å¯¼èˆª */
        .tab-nav { background: #fff; padding: 0 24px; border-bottom: 1px solid #e8ecf1; position: fixed; top: 56px; left: 0; right: 0; z-index: 99; height: 48px; display: flex; align-items: center; gap: 8px; }
        .tab-item { padding: 8px 20px; font-size: 14px; color: #64748b; border-radius: 6px; cursor: pointer; transition: all 0.2s; text-decoration: none; }
        .tab-item:hover { background: #f5f7fa; color: #475569; }
        .tab-item.active { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); color: #fff; font-weight: 500; }

        /* ä¸»å†…å®¹åŒº */
        .main-content { margin-top: 104px; padding: 24px; display: grid; grid-template-columns: 1fr 1fr; gap: 24px; max-width: 1400px; margin-left: auto; margin-right: auto; }
        .left-panel, .right-panel { display: flex; flex-direction: column; gap: 20px; }
        .panel-section { background: #fff; border-radius: 12px; padding: 20px; border: 1px solid #e8ecf1; }
        .section-title { font-size: 15px; font-weight: 600; color: #1e293b; margin-bottom: 16px; display: flex; align-items: center; justify-content: space-between; }

        /* ä¸Šä¼ åŒºåŸŸ */
        .upload-zone { border: 2px dashed #d1d5db; border-radius: 12px; padding: 40px 20px; text-align: center; cursor: pointer; transition: all 0.2s; background: #fafbfc; }
        .upload-zone:hover, .upload-zone.dragover { border-color: #6366f1; background: #f8f7ff; }
        .upload-icon { width: 48px; height: 48px; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); border-radius: 12px; display: flex; align-items: center; justify-content: center; margin: 0 auto 12px; font-size: 24px; }
        .upload-title { font-size: 14px; color: #475569; margin-bottom: 8px; }
        .upload-btn { display: inline-flex; align-items: center; gap: 6px; padding: 8px 20px; background: #fff; border: 1px solid #e8ecf1; border-radius: 8px; font-size: 13px; color: #6366f1; cursor: pointer; margin: 12px 0; }
        .upload-hint { font-size: 12px; color: #94a3b8; line-height: 1.6; }
        .upload-hint a { color: #6366f1; text-decoration: none; }

        /* ä¸Šä¼ æ¨¡å¼åˆ‡æ¢ */
        .upload-mode { margin-bottom: 16px; }
        .upload-mode span { font-size: 13px; color: #475569; margin-right: 12px; }
        .upload-options { display: inline-flex; gap: 16px; }
        .radio-option { display: flex; align-items: center; gap: 6px; font-size: 13px; color: #475569; cursor: pointer; }
        .radio-option input { accent-color: #6366f1; }

        /* é¢„è§ˆç½‘æ ¼ */
        .preview-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 12px; margin-top: 12px; }
        .preview-item { position: relative; }
        .preview-thumb { width: 100%; aspect-ratio: 1; object-fit: cover; border-radius: 8px; border: 1px solid #e8ecf1; }
        .preview-caption { font-size: 11px; color: #64748b; margin-top: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .preview-delete { position: absolute; top: -6px; right: -6px; width: 22px; height: 22px; background: #fff; border: none; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 14px; color: #ef4444; box-shadow: 0 2px 6px rgba(0,0,0,0.15); transition: all 0.2s; z-index: 10; }
        .preview-delete:hover { background: #fef2f2; transform: scale(1.1); }

        /* å‡­è¯è¾“å…¥ */
        .credential-input { width: 100%; padding: 10px 14px; border: 1px solid #e8ecf1; border-radius: 8px; font-size: 13px; background: #fafbfc; }
        .credential-input:focus { outline: none; border-color: #6366f1; background: #fff; }
        .helper { font-size: 12px; color: #94a3b8; margin-top: 8px; line-height: 1.5; }
        .helper code { background: #f1f5f9; padding: 2px 6px; border-radius: 4px; font-size: 11px; }

        /* æ¨¡å‹é€‰æ‹© */
        .model-select, .ratio-select { width: 100%; padding: 10px 14px; border: 1px solid #e8ecf1; border-radius: 8px; font-size: 13px; background: #fff; cursor: pointer; }
        .model-select:focus, .ratio-select:focus { outline: none; border-color: #6366f1; }

        /* æ¯”ä¾‹æŒ‰é’®ç»„ */
        .ratio-btn-group { display: flex; gap: 8px; flex-wrap: wrap; }
        .ratio-btn { display: flex; align-items: center; gap: 6px; padding: 10px 16px; border: 1px solid #e8ecf1; border-radius: 20px; font-size: 13px; color: #475569; background: #fff; cursor: pointer; transition: all 0.2s; }
        .ratio-btn:hover { border-color: #6366f1; background: #f8f7ff; }
        .ratio-btn.active { background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); color: #fff; border-color: transparent; }
        .ratio-icon { width: 14px; height: 14px; border: 1.5px solid currentColor; border-radius: 2px; flex-shrink: 0; }
        .ratio-hint { display: flex; align-items: flex-start; gap: 8px; margin-top: 12px; padding: 12px 14px; background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-radius: 8px; font-size: 12px; color: #92400e; line-height: 1.6; }
        .ratio-hint-icon { font-size: 14px; flex-shrink: 0; }

        /* åˆ†è¾¨ç‡é€‰æ‹© */
        .resolution-group { margin-top: 16px; }
        .resolution-group.hidden { display: none; }

        /* å¼€å§‹å¤„ç†æŒ‰é’® */
        .submit-btn { width: 100%; padding: 14px 24px; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); color: #fff; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; transition: all 0.2s; box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3); }
        .submit-btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4); }
        .submit-btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        .secondary-btn { background: #f8f9fb; color: #475569; border: 1px solid #e8ecf1; box-shadow: none; }
        .secondary-btn:hover:not(:disabled) { background: #f0f2f5; transform: none; box-shadow: none; }
        .form-actions { display: flex; gap: 12px; }
        .form-actions .submit-btn { flex: 1; }

        /* çŠ¶æ€æç¤º */
        .status { font-size: 13px; padding: 10px 14px; border-radius: 8px; margin-top: 12px; }
        .status:empty { display: none; }
        .status.success { background: #ecfdf5; color: #059669; }
        .status.error { background: #fef2f2; color: #dc2626; }
        .status.warning { background: #fffbeb; color: #d97706; }

        /* ä»»åŠ¡åˆ—è¡¨ */
        .task-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
        .task-desc { font-size: 13px; color: #64748b; margin-bottom: 16px; }
        .view-all-btn { padding: 6px 14px; background: #f8f9fb; border: 1px solid #e8ecf1; border-radius: 6px; font-size: 12px; color: #64748b; cursor: pointer; }
        .view-all-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .task-list { display: flex; flex-direction: column; gap: 12px; }
        .history-empty { text-align: center; color: #94a3b8; font-size: 13px; padding: 40px 20px; }

        /* å†å²ä»»åŠ¡é¡¹ */
        .history-item { background: #f8f9fb; border: 1px solid #e8ecf1; border-radius: 10px; padding: 16px; }
        .history-item header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px; }
        .history-meta { display: flex; flex-direction: column; gap: 4px; font-size: 12px; color: #64748b; }
        .history-meta strong { color: #1e293b; font-size: 14px; }
        .history-actions button { padding: 6px 12px; background: #fff; border: 1px solid #e8ecf1; border-radius: 6px; font-size: 12px; color: #475569; cursor: pointer; }
        .history-actions button:hover:not(:disabled) { border-color: #6366f1; color: #6366f1; }
        .history-actions button:disabled { opacity: 0.5; cursor: not-allowed; }
        .history-image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 12px; }
        .history-image { position: relative; }
        .history-image img { width: 100%; aspect-ratio: 1; object-fit: cover; border-radius: 8px; border: 1px solid #e8ecf1; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        .history-image img:hover { transform: scale(1.02); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .history-image .history-actions { margin-top: 8px; }
        .history-image .history-actions button { width: 100%; font-size: 11px; }

        /* å›¾ç‰‡é¢„è§ˆå¼¹çª— */
        .image-preview-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 9999; display: none; align-items: center; justify-content: center; padding: 20px; }
        .image-preview-modal.active { display: flex; }
        .image-preview-modal img { max-width: 90vw; max-height: 90vh; object-fit: contain; border-radius: 8px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); }
        .image-preview-close { position: absolute; top: 20px; right: 20px; width: 44px; height: 44px; background: rgba(255,255,255,0.1); border: none; border-radius: 50%; color: #fff; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background 0.2s; }
        .image-preview-close:hover { background: rgba(255,255,255,0.2); }
        .image-preview-actions { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; }
        .image-preview-actions button { padding: 10px 20px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3); border-radius: 8px; color: #fff; font-size: 14px; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: background 0.2s; }
        .image-preview-actions button:hover { background: rgba(255,255,255,0.25); }

        /* å›¾åƒè¾“å‡º */
        .image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 16px; margin-top: 16px; }
        .image-grid figure { margin: 0; }
        .image-grid img { width: 100%; border-radius: 8px; border: 1px solid #e8ecf1; }
        .image-grid figcaption { font-size: 12px; color: #64748b; margin-top: 6px; }

        /* éšè—å…ƒç´  */
        .hidden { display: none !important; }
        .file-input { display: none; }

        /* å“åº”å¼ */
        @media (max-width: 1024px) { .main-content { grid-template-columns: 1fr; } }
        @media (max-width: 768px) {
            .tab-nav { overflow-x: auto; padding: 0 16px; }
            .main-content { padding: 16px; }
            .form-actions { flex-direction: column; }
        }
    </style>
</head>
<body>
    <!-- é¡¶éƒ¨å¯¼èˆª -->
    <header class="top-header">
        <div class="header-left">
        </div>
        <span class="page-title">å°èŠ±æå–å°åŠ©æ‰‹</span>
        <div class="header-right">
            <button class="header-icon-btn">ğŸ””</button>
        </div>
    </header>

    <!-- åŠŸèƒ½æ ‡ç­¾å¯¼èˆª -->
    <nav class="tab-nav">
        <a href="tiqu-yinhua.html" class="tab-item active">æå–å°èŠ±</a>
        <a href="situcankao.html" class="tab-item">å››å›¾å‚è€ƒ</a>
        <a href="shitucankao.html" class="tab-item">åå›¾å‚è€ƒ</a>
        <a href="zidingyi.html" class="tab-item">è‡ªå®šä¹‰</a>
        <a href="cpsj.html" class="tab-item">äº§å“æµ·æŠ¥</a>
    </nav>

    <!-- ä¸»å†…å®¹åŒº -->
    <main class="main-content">
        <!-- å·¦ä¾§é¢æ¿ -->
        <div class="left-panel">
            <!-- è®¤è¯ä¿¡æ¯ -->
            <div class="panel-section">
                <h2 class="section-title">APIKeyå¡«å†™åŒº</h2>
                <input type="password" id="credential" class="credential-input" placeholder="ç²˜è´´è®¿é—®å‡­è¯" required autocomplete="off">
                <p class="helper">å¡«å†™DUUè°ƒç”¨ç«™çš„APIkeyï¼Œå»ºè®®åˆ›å»ºapikeyåˆ†ç»„ä¸ºé™æ—¶ç‰¹ä»·ã€ä¼˜è´¨geminiã€å®˜è½¬gemini</p>
            </div>

            <!-- ä¸Šä¼ å›¾ç‰‡ -->
            <div class="panel-section">
                <h2 class="section-title">ä¸Šä¼ å›¾ç‰‡</h2>
                <div class="upload-mode">
                    <span>ä¸Šä¼ æ¨¡å¼</span>
                    <div class="upload-options">
                        <label class="radio-option">
                            <input type="radio" name="upload-mode" value="single" checked> å•å¼ å›¾ç‰‡
                        </label>
                        <label class="radio-option">
                            <input type="radio" name="upload-mode" value="folder"> å›¾ç‰‡æ–‡ä»¶å¤¹
                        </label>
                    </div>
                </div>
                
                <!-- å•å¼ ä¸Šä¼  -->
                <div id="single-upload-group">
                    <div class="upload-zone" id="uploadZone">
                        <div class="upload-icon">ğŸ–¼ï¸</div>
                        <p class="upload-title">ä¸Šä¼ å›¾ç‰‡</p>
                        <p class="upload-hint">æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„ï¼Œæˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</p>
                        <label class="upload-btn">
                            <input type="file" class="file-input" id="image-file" accept="image/*">
                            ğŸ“¤ é€‰æ‹©æ–‡ä»¶
                        </label>
                        <p class="upload-hint">æ ¼å¼ï¼šJPGã€PNGã€WebP | æ–‡ä»¶å¤§å° â‰¤ 10MB<br>ğŸ”’ æ”¯æŒç²˜è´´å›¾ç‰‡ï¼ˆCtrl+Vï¼‰</p>
                    </div>
                    <div id="single-preview" class="folder-preview" hidden>
                        <p class="helper" style="margin:0">é¢„è§ˆæ‰€é€‰å›¾ç‰‡ï¼š</p>
                        <div id="single-preview-grid" class="preview-grid"></div>
                    </div>
                    <div style="margin-top: 12px;">
                        <label class="helper">æ‰§è¡Œæ¬¡æ•°</label>
                        <div style="display: flex; gap: 8px; margin-top: 6px;">
                            <select id="single-exec-count" class="credential-input" style="flex: 1;">
                                <option value="1" selected>1 æ¬¡</option>
                                <option value="10">10 æ¬¡</option>
                                <option value="custom">è‡ªå®šä¹‰</option>
                            </select>
                            <input type="number" id="single-exec-custom" class="credential-input" min="1" max="1000" value="5" style="flex: 1; display: none;" placeholder="è¾“å…¥æ¬¡æ•°">
                        </div>
                        <p class="helper">å¯¹åŒä¸€å¼ å›¾ç‰‡å¹¶å‘æ‰§è¡Œå¤šæ¬¡ç”Ÿæˆï¼Œè¶…è¿‡20æ¬¡è‡ªåŠ¨åˆ†æ‰¹æ‰§è¡Œ</p>
                    </div>
                    <div id="single-progress-container" style="margin-top: 12px;"></div>
                    <div id="single-optimize-group" style="margin-top: 12px;">
                        <label class="radio-option">
                            <input type="checkbox" id="single-optimize-toggle"> å¯ç”¨æç¤ºè¯ä¼˜åŒ–ï¼ˆAIåˆ†æå›¾ç‰‡ç”Ÿæˆä¼˜åŒ–æç¤ºè¯ï¼‰
                        </label>
                        <p class="helper">å¼€å¯åï¼ŒAIä¼šå…ˆåˆ†æå›¾ç‰‡å†…å®¹ï¼Œç”Ÿæˆé’ˆå¯¹æ€§çš„æç¤ºè¯ï¼Œæå–æ•ˆæœæ›´ç²¾å‡†</p>
                    </div>
                </div>

                <!-- æ–‡ä»¶å¤¹ä¸Šä¼  -->
                <div id="folder-upload-group" class="hidden">
                    <div class="upload-zone">
                        <div class="upload-icon">ğŸ“</div>
                        <p class="upload-title">ä¸Šä¼ æ–‡ä»¶å¤¹</p>
                        <label class="upload-btn">
                            <input type="file" class="file-input" id="image-folder" webkitdirectory directory multiple accept="image/*">
                            ğŸ“¤ é€‰æ‹©æ–‡ä»¶å¤¹
                        </label>
                        <p class="upload-hint">ä¸Šä¼ å¤šå°‘å¼ å°±å¹¶å‘å¤„ç†å¤šå°‘å¼ </p>
                    </div>
                    <div id="folder-preview" class="folder-preview" hidden>
                        <p class="helper" style="margin:0">å·²é€‰æ‹©çš„å›¾ç‰‡é¢„è§ˆï¼š</p>
                        <div id="folder-preview-grid" class="preview-grid"></div>
                    </div>
                    <div style="margin-top: 12px;">
                        <label class="helper">å¹¶å‘æ•°é‡</label>
                        <select id="concurrent-limit" class="credential-input" style="margin-top: 6px;">
                            <option value="1">1 (é¡ºåºå¤„ç†)</option>
                            <option value="5">5 å¹¶å‘</option>
                            <option value="10">10 å¹¶å‘</option>
                            <option value="20" selected>20 å¹¶å‘ (æœ€å¤§)</option>
                        </select>
                        <p class="helper">åŒæ—¶å¤„ç†çš„å›¾ç‰‡æ•°é‡ï¼Œä¸Šä¼ å¤šå°‘å¼ å°±å¹¶å‘å¤„ç†å¤šå°‘å¼ </p>
                    </div>
                    <div id="batch-progress-container" style="margin-top: 12px;"></div>
                    <div id="auto-optimize-group" style="margin-top: 12px;">
                        <label class="radio-option">
                            <input type="checkbox" id="auto-optimize-toggle"> å¯ç”¨æç¤ºè¯ä¼˜åŒ–ï¼ˆé€å¼ åˆ†æå›¾ç‰‡ç”Ÿæˆä¼˜åŒ–æç¤ºè¯ï¼‰
                        </label>
                        <p class="helper">å¼€å¯åï¼ŒAIä¼šå…ˆåˆ†ææ¯å¼ å›¾ç‰‡å†…å®¹ï¼Œç”Ÿæˆé’ˆå¯¹æ€§çš„æç¤ºè¯ï¼Œæå–æ•ˆæœæ›´ç²¾å‡†</p>
                    </div>
                    <div style="margin-top: 12px;">
                        <label class="radio-option">
                            <input type="checkbox" id="sound-toggle" checked> ğŸ”” å®Œæˆæç¤ºéŸ³
                        </label>
                        <p class="helper">æ‰¹é‡å¤„ç†å®Œæˆæ—¶æ’­æ”¾æç¤ºéŸ³</p>
                    </div>
                </div>
            </div>

            <!-- æ¨¡å‹ä¸å‚æ•° -->
            <div class="panel-section">
                <h2 class="section-title">æ¨¡å‹ä¸å‚æ•°</h2>
                <div style="margin-bottom: 16px;">
                    <label class="helper">æ¨¡å‹é€‰æ‹©</label>
                    <select id="model-selection" class="model-select" style="margin-top: 6px;">
                        <option value="gemini-2.5-flash-image" selected>Gemini 2.5 Flash Imageï¼ˆé‡å¤§ç®¡é¥±ã€ä¾¿å®œï¼‰</option>
                        <option value="gemini-3-pro-image-preview">Gemini 3 Pro Image Previewï¼ˆè´µã€ä½†ç²¾å‡†ï¼‰</option>
                    </select>
                </div>
                <input type="hidden" id="response-modalities" value="IMAGE">
                <div>
                    <label class="helper">å›¾åƒé•¿å®½æ¯”</label>
                    <div class="ratio-btn-group" style="margin-top: 8px;">
                        <button type="button" class="ratio-btn active" data-ratio="1:1"><span class="ratio-icon"></span> 1:1</button>
                        <button type="button" class="ratio-btn" data-ratio="2:3"><span class="ratio-icon" style="width:12px;height:18px;"></span> 2:3</button>
                        <button type="button" class="ratio-btn" data-ratio="3:4"><span class="ratio-icon" style="width:12px;height:16px;"></span> 3:4</button>
                        <button type="button" class="ratio-btn" data-ratio="9:16"><span class="ratio-icon" style="width:9px;height:16px;"></span> 9:16</button>
                        <button type="button" class="ratio-btn" data-ratio="3:2"><span class="ratio-icon" style="width:18px;height:12px;"></span> 3:2</button>
                        <button type="button" class="ratio-btn" data-ratio="4:3"><span class="ratio-icon" style="width:16px;height:12px;"></span> 4:3</button>
                        <button type="button" class="ratio-btn" data-ratio="16:9"><span class="ratio-icon" style="width:16px;height:9px;"></span> 16:9</button>
                    </div>
                    <div class="ratio-hint">
                        <span class="ratio-hint-icon">ğŸ’¡</span>
                        <span>æ³¨æ„ï¼šå°èŠ±æ˜¯çºµå›¾ï¼Œå°±é€‰çºµå›¾ï¼Œæ˜¯æ¨ªå›¾é€‰æ¨ªå›¾ï¼Œæ³¨æ„æ˜¯å°èŠ±çš„æ¯”ä¾‹ï¼Œä¸æ˜¯åŸå›¾çš„æ¯”ä¾‹ï¼Œé¿å…å°èŠ±å›¾æ¡ˆæ®‹ç¼º</span>
                    </div>
                    <input type="hidden" id="aspect-ratio" value="1:1">
                </div>
                <div id="resolution-group" class="resolution-group hidden">
                    <label class="helper">è¾“å‡ºåˆ†è¾¨ç‡</label>
                    <select id="resolution-select" class="model-select" style="margin-top: 6px;">
                        <option value="1024" selected>1Kï¼ˆ1024ï¼‰</option>
                        <option value="2048">2Kï¼ˆ2048ï¼‰</option>
                        <option value="4096">4Kï¼ˆ4096ï¼‰</option>
                    </select>
                    <p class="helper">ä»… Gemini 3 Pro Image Preview æ”¯æŒåˆ†è¾¨ç‡é€‰æ‹©</p>
                </div>
            </div>

            <!-- æ“ä½œæŒ‰é’® -->
            <div class="form-actions">
                <button type="button" class="submit-btn" id="submitBtn">âœ¨ å¼€å§‹å¤„ç†</button>
                <button type="button" class="submit-btn secondary-btn" id="pause-processing" disabled>æš‚åœå¤„ç†</button>
            </div>
            <p id="status" class="status" aria-live="polite"></p>

            <!-- è¾“å‡ºåŒºåŸŸ -->
            <div class="panel-section" id="output-section" hidden>
                <h2 class="section-title">å¤„ç†ç»“æœ</h2>
                <div id="image-output" class="image-grid"></div>
                <div id="text-output"></div>
            </div>
        </div>

        <!-- å³ä¾§é¢æ¿ -->
        <div class="right-panel">
            <div class="panel-section" style="flex: 1;">
                <div class="task-header">
                    <h2 class="section-title" style="margin-bottom: 0;">ä»»åŠ¡å†å²</h2>
                    <button class="view-all-btn" id="download-all-images" disabled>ä¸‹è½½å…¨éƒ¨å›¾ç‰‡</button>
                </div>
                <p class="task-desc">ç”Ÿæˆå›¾ç‰‡å¤§çº¦éœ€è¦2-4åˆ†é’Ÿï¼Œå±•ç¤ºæœ€æ–°ä»»åŠ¡è®°å½•</p>
                <p id="history-empty" class="history-empty">æš‚æ— ä»»åŠ¡è®°å½•</p>
                <div id="task-history-list" class="task-list" aria-live="polite"></div>
            </div>
        </div>
    </main>

    <!-- å›¾ç‰‡é¢„è§ˆå¼¹çª— -->
    <div class="image-preview-modal" id="imagePreviewModal">
        <button class="image-preview-close" id="previewClose">âœ•</button>
        <img src="" alt="é¢„è§ˆå¤§å›¾" id="previewImage">
        <div class="image-preview-actions">
            <button id="previewDownload">ğŸ“¥ ä¸‹è½½å›¾ç‰‡</button>
        </div>
    </div>

    <script src="../scripts/duu-db.js"></script>
    <script src="../scripts/apikeys.js"></script>
    <script src="../scripts/batch-processor.js"></script>
    <script src="../scripts/auth.js"></script>
    <script src="../scripts/image-server.js"></script>
    <script>
      // é¡µé¢æ ‡è¯†
      const PAGE_KEY = 'gemini-extract';
      
      // DOM å…ƒç´ 
      const statusEl = document.getElementById("status");
      const imageOutput = document.getElementById("image-output");
      const textOutput = document.getElementById("text-output");
      const outputSection = document.getElementById("output-section");
      const credentialInput = document.getElementById("credential");
      const modelSelect = document.getElementById("model-selection");
      const pauseButton = document.getElementById("pause-processing");
      const submitBtn = document.getElementById("submitBtn");
      const uploadModeRadios = document.querySelectorAll("input[name='upload-mode']");
      const singleUploadGroup = document.getElementById("single-upload-group");
      const folderUploadGroup = document.getElementById("folder-upload-group");
      const singleFileInput = document.getElementById("image-file");
      const folderInput = document.getElementById("image-folder");
      const resolutionGroup = document.getElementById("resolution-group");
      const resolutionSelect = document.getElementById("resolution-select");
      const singlePreview = document.getElementById("single-preview");
      const singlePreviewGrid = document.getElementById("single-preview-grid");
      const taskHistoryList = document.getElementById("task-history-list");
      const historyEmptyState = document.getElementById("history-empty");
      const downloadAllBtn = document.getElementById("download-all-images");
      const folderPreview = document.getElementById("folder-preview");
      const folderPreviewGrid = document.getElementById("folder-preview-grid");
      const uploadZone = document.getElementById("uploadZone");
      const responseModalitiesInput = document.getElementById("response-modalities");
      const promptInput = document.getElementById("prompt-input") || null;
      const singleExecCountSelect = document.getElementById("single-exec-count");
      const singleExecCustomInput = document.getElementById("single-exec-custom");

      // å•å¼ æ‰§è¡Œæ¬¡æ•°é€‰æ‹©åˆ‡æ¢
      if (singleExecCountSelect) {
        singleExecCountSelect.addEventListener('change', () => {
          if (singleExecCountSelect.value === 'custom') {
            singleExecCustomInput.style.display = 'block';
          } else {
            singleExecCustomInput.style.display = 'none';
          }
        });
      }

      // è·å–å•å¼ æ‰§è¡Œæ¬¡æ•°
      const getSingleExecCount = () => {
        if (!singleExecCountSelect) return 1;
        if (singleExecCountSelect.value === 'custom') {
          const customValue = parseInt(singleExecCustomInput?.value || '1', 10);
          return Math.max(1, Math.min(1000, customValue));
        }
        return parseInt(singleExecCountSelect.value, 10) || 1;
      };

      // åˆå§‹åŒ–ç¼“å­˜ç³»ç»Ÿ
      const pageCache = typeof CacheManager !== 'undefined' ? new CacheManager('gemini-extract') : null;
      
      // æ–­ç‚¹ç»­ä¼ çŠ¶æ€ç®¡ç†
      const batchTaskState = typeof BatchTaskState !== 'undefined' ? new BatchTaskState('gemini-extract') : null;
      
      // ESC å…³é—­å›¾ç‰‡é¢„è§ˆå¼¹çª—
      if (window.initEscClose) {
        initEscClose('#imagePreviewModal', () => {
          document.getElementById('imagePreviewModal').classList.remove('active');
        });
      }
      
      // API Key ç¼“å­˜ - è¾“å…¥æ—¶è‡ªåŠ¨ä¿å­˜ï¼ˆå¸¦é˜²æŠ–ï¼‰
      let apiKeyTimer = null;
      if (credentialInput) {
        credentialInput.addEventListener('input', (e) => {
          const apiKey = e.target.value.trim();
          if (apiKeyTimer) clearTimeout(apiKeyTimer);
          apiKeyTimer = setTimeout(async () => {
            if (apiKey) {
              await pageCache.set('apiKey', apiKey, { ttl: null });
            }
          }, 500); // åœæ­¢è¾“å…¥ 500ms åä¿å­˜
        });
      }
      
      // å¸¸é‡å’ŒçŠ¶æ€ - å¿…é¡»åœ¨ä½¿ç”¨å‰å®šä¹‰
      const BUILT_IN_PROMPT = "è¿™æ˜¯ä¸€å¼ å›¾ç‰‡ï¼Œæˆ‘éœ€è¦æå–å›¾ç‰‡ä¸­ä¸»ä½“å°èŠ±éƒ¨åˆ†ã€è¦æ±‚ä¿æŒå°èŠ±å®Œæ•´æ€§å’Œæ¸…æ™°åº¦ï¼Œé¿å…æ¨¡ç³Šæˆ–å¤±çœŸï¼ŒåŒæ—¶ä¿ç•™ç»†èŠ‚å’Œè‰²å½©é¥±å’Œåº¦ï¼Œä¿æŒå›¾æ¡ˆçš„åŸå§‹é£æ ¼å’Œè´¨æ„Ÿï¼Œä¸æ”¹å˜å›¾åƒçš„æ•´ä½“æ„å›¾å’Œæ¯”ä¾‹å…³ç³»ã€‚";
      let folderFiles = [];
      let taskHistory = [];
      let previewObjectUrls = [];
      let singlePreviewUrls = [];
      let isPaused = false;
      let isRestoring = false;

      const TASK_STATE_KEY = 'gemini_extract_pattern_last_task';
      const TASK_STATE_VERSION = 1;
      const TASK_STATE_EXPIRY_MS = 12 * 60 * 60 * 1000;
      const MAX_HISTORY_ENTRIES = 5; // å‡å°‘å†å²è®°å½•æ•°é‡ï¼Œé¿å…å†…å­˜å ç”¨è¿‡é«˜

      // è·å–ä¼˜åŒ–å¼€å…³å…ƒç´ 
      const autoOptimizeToggle = document.getElementById("auto-optimize-toggle");
      const singleOptimizeToggle = document.getElementById("single-optimize-toggle");
      const soundToggle = document.getElementById("sound-toggle");
      
      // åˆå§‹åŒ–æç¤ºéŸ³å¼€å…³çŠ¶æ€
      if (soundToggle) {
        soundToggle.checked = window.isSoundEnabled ? window.isSoundEnabled() : true;
        soundToggle.addEventListener('change', () => {
          if (window.toggleNotificationSound) {
            window.toggleNotificationSound();
          } else {
            localStorage.setItem('duu_sound_enabled', soundToggle.checked);
          }
        });
      }
      
      // åˆå§‹åŒ–å…¨å±€APIKey
      if (window.initApiKeyInput) {
        window.initApiKeyInput('gemini', 'credential');
      }
      
      // é¡µé¢åŠ è½½æ—¶æ¢å¤ç¼“å­˜çŠ¶æ€
      (async function restoreCachedState() {
        isRestoring = true;
        
        try {
          // æ‰¹é‡è¯»å–å…³é”®ç¼“å­˜ï¼ˆå‡å°‘å¼‚æ­¥è°ƒç”¨æ¬¡æ•°ï¼‰
          const [cachedApiKey, cachedModel, cachedAspectRatio, cachedResolution, cachedUploadMode] = await Promise.all([
            pageCache.get('apiKey'),
            pageCache.get('model'),
            pageCache.get('aspectRatio'),
            pageCache.get('resolution'),
            pageCache.get('uploadMode')
          ]);
          
          // æ¢å¤ API Key
          if (cachedApiKey && credentialInput) {
            credentialInput.value = cachedApiKey;
          }
          
          // æ¢å¤æ¨¡å‹é€‰æ‹©ï¼ˆä¸è§¦å‘äº‹ä»¶ï¼Œé¿å…ä¸å¿…è¦çš„ DOM æ“ä½œï¼‰
          if (cachedModel && modelSelect) {
            modelSelect.value = cachedModel;
            // æ‰‹åŠ¨æ›´æ–°åˆ†è¾¨ç‡æ˜¾ç¤ºçŠ¶æ€
            const selected = modelRegistry[cachedModel];
            if (selected) {
              const shouldShowResolution = Boolean(selected.supportsResolution);
              resolutionGroup.classList.toggle("hidden", !shouldShowResolution);
            }
          }
          
          // æ¢å¤é•¿å®½æ¯”ï¼ˆæ‰¹é‡æ›´æ–° DOMï¼‰
          if (cachedAspectRatio) {
            document.getElementById('aspect-ratio').value = cachedAspectRatio;
            const ratioBtns = document.querySelectorAll('.ratio-btn');
            ratioBtns.forEach(btn => {
              btn.classList.toggle('active', btn.dataset.ratio === cachedAspectRatio);
            });
          }
          
          // æ¢å¤åˆ†è¾¨ç‡
          if (cachedResolution && resolutionSelect) {
            resolutionSelect.value = cachedResolution;
          }
          
          // æ¢å¤ä¸Šä¼ æ¨¡å¼ï¼ˆä¸è§¦å‘äº‹ä»¶ï¼‰
          if (cachedUploadMode) {
            const radio = document.querySelector(`input[name="upload-mode"][value="${cachedUploadMode}"]`);
            if (radio) {
              radio.checked = true;
              // æ‰‹åŠ¨æ›´æ–°æ˜¾ç¤ºçŠ¶æ€
              if (cachedUploadMode === 'folder') {
                singleUploadGroup.classList.add('hidden');
                folderUploadGroup.classList.remove('hidden');
              }
            }
          }
          
          // æ‰¹é‡è¯»å–æ¬¡è¦ç¼“å­˜
          const [cachedAutoOptimize, cachedSingleOptimize, cachedFolderLimit] = await Promise.all([
            pageCache.get('autoOptimize'),
            pageCache.get('singleOptimize'),
            pageCache.get('folderLimit')
          ]);
          
          // æ¢å¤ä¼˜åŒ–å¼€å…³
          if (cachedAutoOptimize !== null && autoOptimizeToggle) {
            autoOptimizeToggle.checked = cachedAutoOptimize;
          }
          
          if (cachedSingleOptimize !== null && singleOptimizeToggle) {
            singleOptimizeToggle.checked = cachedSingleOptimize;
          }
          
          // æ¢å¤æ–‡ä»¶å¤¹é™åˆ¶ï¼ˆå·²ç§»é™¤è¯¥åŠŸèƒ½ï¼‰
          
          isRestoring = false;
          
          // ä» IndexedDB åŠ è½½ä»»åŠ¡å†å²
          setTimeout(async () => {
            try {
              const dbTasks = await HistoryDB.getTasks(PAGE_KEY);
              if (dbTasks && dbTasks.length > 0) {
                taskHistory = dbTasks.map(task => ({
                  ...task,
                  createdAt: task.createdAt ? new Date(task.createdAt) : new Date()
                }));
                renderHistory();
              }
            } catch (e) {
              console.warn('ä»æ•°æ®åº“åŠ è½½å†å²å¤±è´¥:', e);
            }
          }, 100);
          
        } catch (error) {
          console.error('æ¢å¤ç¼“å­˜çŠ¶æ€å¤±è´¥:', error);
          isRestoring = false;
        }
      })();

      const pruneHistory = (history = []) => history.slice(0, MAX_HISTORY_ENTRIES);

      const prepareHistoryForStorage = (history = []) =>
        pruneHistory(history).map((entry) => ({
          ...entry,
          createdAt: entry.createdAt instanceof Date ? entry.createdAt.getTime() : entry.createdAt,
        }));

      const restoreHistoryFromStorage = (history = []) =>
        history.map((entry) => ({
          ...entry,
          createdAt: entry.createdAt ? new Date(entry.createdAt) : new Date(),
        }));

      const readTaskState = () => {
        try {
          const raw = localStorage.getItem(TASK_STATE_KEY);
          if (!raw) return null;
          const parsed = JSON.parse(raw);
          if (!parsed || parsed.version !== TASK_STATE_VERSION) {
            return null;
          }
          if (parsed.updatedAt && Date.now() - parsed.updatedAt > TASK_STATE_EXPIRY_MS) {
            localStorage.removeItem(TASK_STATE_KEY);
            return null;
          }
          return parsed;
        } catch (error) {
          console.warn('è¯»å–ä»»åŠ¡ç¼“å­˜å¤±è´¥:', error);
          return null;
        }
      };

      const writeTaskState = (state) => {
        try {
          const payload = {
            ...state,
            version: TASK_STATE_VERSION,
            updatedAt: state?.updatedAt || Date.now(),
          };
          localStorage.setItem(TASK_STATE_KEY, JSON.stringify(payload));
        } catch (error) {
          console.warn('ä¿å­˜ä»»åŠ¡ç¼“å­˜å¤±è´¥:', error);
        }
      };

      const mergeTaskState = (patch = {}) => {
        const current = readTaskState() || {};
        const next = {
          ...current,
          updatedAt: Date.now(),
        };

        if (patch.form) {
          next.form = { ...(current.form || {}), ...patch.form };
        }

        if (patch.hasOwnProperty('status')) {
          next.status = patch.status ? { ...patch.status } : null;
        }

        if (patch.hasOwnProperty('history')) {
          next.history = prepareHistoryForStorage(patch.history || []);
        } else if (current.history) {
          next.history = prepareHistoryForStorage(current.history);
        }

        if (patch.hasOwnProperty('output')) {
          if (!patch.output) {
            next.output = null;
          } else {
            next.output = {
              ...(current.output || {}),
              ...patch.output,
            };
          }
        }

        if (patch.hasOwnProperty('folderMeta')) {
          next.folderMeta = patch.folderMeta || null;
        }

        writeTaskState(next);
        return next;
      };

      const clearTaskState = () => {
        try {
          localStorage.removeItem(TASK_STATE_KEY);
        } catch (error) {
          console.warn('æ¸…ç†ä»»åŠ¡ç¼“å­˜å¤±è´¥:', error);
        }
      };

      const setStatus = (message = '', type = '', { skipCache = false } = {}) => {
        const normalizedType = typeof type === 'string' ? type.trim() : '';
        statusEl.textContent = message;
        statusEl.className = normalizedType ? `status ${normalizedType}` : 'status';

        if (skipCache) {
          return;
        }

        if (message && message.trim()) {
          mergeTaskState({
            status: {
              message,
              type: normalizedType,
            },
          });
        } else {
          mergeTaskState({ status: null });
        }
      };

      const captureFormState = () => ({
        model: modelSelect.value,
        aspectRatio: document.getElementById('aspect-ratio').value,
        resolution: resolutionSelect.value,
        uploadMode: getUploadMode(),
        autoOptimize: autoOptimizeToggle.checked,
        singleOptimize: singleOptimizeToggle.checked,
        prompt: promptInput ? promptInput.value.trim() : '',
      });

      const buildFolderMeta = () => {
        const mode = getUploadMode();
        if (mode === 'folder') {
          return {
            mode,
            total: folderFiles.length,
            fileNames: folderFiles.slice(0, 10).map((file) => file.name),
          };
        }
        if (mode === 'single') {
          return {
            mode,
            fileName: singleFileInput.files?.[0]?.name || null,
          };
        }
        return { mode };
      };

      // é˜²æŠ–å‡½æ•° - å‡å°‘é¢‘ç¹çš„ç¼“å­˜å†™å…¥
      let syncFormStateTimer = null;
      const syncFormState = async () => {
        if (isRestoring) return;
        
        // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
        if (syncFormStateTimer) {
          clearTimeout(syncFormStateTimer);
        }
        
        // å»¶è¿Ÿ 300ms åå†ä¿å­˜ï¼Œé¿å…é¢‘ç¹å†™å…¥
        syncFormStateTimer = setTimeout(async () => {
          try {
            const formState = captureFormState();
            // æ‰¹é‡ä¿å­˜åˆ°ç¼“å­˜ç³»ç»Ÿ
            await Promise.all([
              pageCache.set('model', formState.model, { ttl: null }),
              pageCache.set('aspectRatio', formState.aspectRatio, { ttl: null }),
              pageCache.set('resolution', formState.resolution, { ttl: null }),
              pageCache.set('uploadMode', formState.uploadMode, { ttl: null }),
              pageCache.set('folderLimit', formState.folderLimit, { ttl: null }),
              pageCache.set('autoOptimize', formState.autoOptimize, { ttl: null }),
              pageCache.set('singleOptimize', formState.singleOptimize, { ttl: null })
            ]);
            
            // ä¿æŒæ—§çš„ localStorage å…¼å®¹
            mergeTaskState({
              form: formState,
            });
          } catch (error) {
            console.error('ä¿å­˜è¡¨å•çŠ¶æ€å¤±è´¥:', error);
          }
        }, 300);
      };

      const syncFolderMeta = () => {
        if (isRestoring) return;
        mergeTaskState({
          folderMeta: buildFolderMeta(),
        });
      };

      // æ¨¡å‹é…ç½®
      const modelRegistry = {
        "gemini-2.5-flash-image": {
          label: "Gemini 2.5 Flash Image",
          endpoint: (apiKey) => `/v1beta/models/gemini-2.5-flash-image:generateContent?key=${encodeURIComponent(apiKey)}`,
          hint: "é«˜è´¨é‡å›¾åƒç”Ÿæˆæ¨¡å‹ï¼Œé€‚åˆå¤§éƒ¨åˆ†å›¾åƒç”Ÿæˆ/ç¼–è¾‘éœ€æ±‚ã€‚",
          supportsResolution: false,
        },
        "gemini-3-pro-image-preview": {
          label: "Gemini 3 Pro Image Preview",
          endpoint: (apiKey) => `/v1beta/models/gemini-3-pro-image-preview:generateContent?key=${encodeURIComponent(apiKey)}`,
          hint: "Gemini 3 é¢„è§ˆæ¨¡å‹ï¼Œé€‚åˆå¿«é€Ÿé¢„è§ˆæˆ–è½»é‡åœºæ™¯ã€‚",
          supportsResolution: true,
        },
        "gemini-2.5-flash-lite-nothinking": {
          label: "Gemini 2.5 Flash Lite (æç¤ºè¯ä¼˜åŒ–)",
          endpoint: (apiKey) => `/v1beta/models/gemini-2.5-flash-lite-nothinking:generateContent?key=${encodeURIComponent(apiKey)}`,
          hint: "è½»é‡çº§å¯¹è¯æ¨¡å‹ï¼Œç”¨äºæç¤ºè¯ä¼˜åŒ–ã€‚",
          supportsResolution: false,
          isOptimizer: true,
        },
      };

      // ä¸ºå›¾ç‰‡ç”Ÿæˆä¼˜åŒ–æç¤ºè¯
      const optimizePromptForImage = async (imageFile, credential) => {
        const optimizerModel = modelRegistry["gemini-2.5-flash-lite-nothinking"];

        const systemPrompt = `åˆ†æå›¾ç‰‡ä¸­çš„å°èŠ±å›¾æ¡ˆï¼Œç”Ÿæˆæå–æç¤ºè¯ã€‚

è¦æ±‚ï¼š
1. è¯†åˆ«å°èŠ±çš„ä¸»ä½“å†…å®¹ã€é£æ ¼ã€è‰²å½©ã€å›¾æ¡ˆç‰¹å¾
2. æè¿°å°èŠ±çš„ç»†èŠ‚ï¼šçº¹ç†ã€è¾¹ç¼˜ã€è‰²å½©é¥±å’Œåº¦
3. å¼ºè°ƒï¼šä¿æŒå°èŠ±å®Œæ•´æ€§ã€æ¸…æ™°åº¦ã€é¿å…å¤±çœŸã€ä¿ç•™åŸå§‹è´¨æ„Ÿ

è¾“å‡ºæ ¼å¼ï¼šç›´æ¥è¾“å‡ºæç¤ºè¯ï¼Œä¸è¦ä»»ä½•è§£é‡Šã€å‰ç¼€æˆ–åç¼€ã€‚`;

        const userInstruction = `${systemPrompt}\n\nåˆ†æè¿™å¼ å›¾ç‰‡çš„å°èŠ±å›¾æ¡ˆï¼Œç”Ÿæˆæå–æç¤ºè¯ï¼š`;

        const { base64, mimeType } = await readFileAsBase64(imageFile);

        const body = {
          contents: [
            {
              role: "user",
              parts: [
                { text: userInstruction },
                {
                  inline_data: {
                    mime_type: mimeType || "image/jpeg",
                    data: base64,
                  },
                },
              ],
            },
          ],
        };

        const { json } = await executeRequest(body, credential, credential, optimizerModel);

        const candidates = json?.candidates || [];
        let optimizedText = "";

        candidates.forEach((candidate) => {
          candidate.content?.parts?.forEach((part) => {
            if (part.text) {
              optimizedText += part.text;
            }
          });
        });

        return optimizedText.trim() || BUILT_IN_PROMPT;
      };

      // å·¥å…·å‡½æ•°
      const readFileAsBase64 = (file) =>
        new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => {
            const result = reader.result;
            const base64 = result.split(",").pop();
            resolve({ base64, mimeType: file.type });
          };
          reader.onerror = () => reject(reader.error);
          reader.readAsDataURL(file);
        });

      const escapeHtml = (value) =>
        value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");

      const formatDate = (date) =>
        `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, "0")}-${String(date.getDate()).padStart(2, "0")} ${String(date.getHours()).padStart(2, "0")}:${String(date.getMinutes()).padStart(2, "0")}:${String(date.getSeconds()).padStart(2, "0")}`;

      const getExtensionFromMime = (mimeType = "") => {
        const [, subtype = "png"] = mimeType.split("/");
        return subtype.split("+")[0];
      };

      const buildImageHref = ({ mimeType, data, url }) =>
        url || `data:${mimeType || "image/png"};base64,${data}`;

      const getUploadMode = () => document.querySelector("input[name='upload-mode']:checked").value;

      // åŠ è½½çŠ¶æ€åˆ‡æ¢
      const toggleLoading = (isLoading) => {
        submitBtn.disabled = isLoading;
        pauseButton.disabled = !isLoading;
        if (isLoading) {
          setStatus("æ­£åœ¨å‘é€è¯·æ±‚ï¼Œè¯·ç¨å€™...");
        }
      };

      // ä¸Šä¼ æ¨¡å¼åˆ‡æ¢
      const updateUploadVisibility = ({ skipClear = false } = {}) => {
        const mode = getUploadMode();
        const isFolder = mode === "folder";
        singleUploadGroup.classList.toggle("hidden", isFolder);
        folderUploadGroup.classList.toggle("hidden", !isFolder);
        singleFileInput.disabled = isFolder;
        folderInput.disabled = !isFolder;
        if (!skipClear) {
          if (!isFolder) {
            folderFiles = [];
            clearFolderPreview();
          } else {
            singleFileInput.value = "";
            clearSinglePreview();
          }
        }
        syncFormState();
        if (!skipClear) {
          syncFolderMeta();
        }
      };

      uploadModeRadios.forEach((radio) => {
        radio.addEventListener("change", () => {
          updateUploadVisibility();
          setStatus("");
          syncFormState();
        });
      });

      // é¢„è§ˆåŠŸèƒ½
      const clearFolderPreview = () => {
        previewObjectUrls.forEach((url) => URL.revokeObjectURL(url));
        previewObjectUrls = [];
        folderPreviewGrid.innerHTML = "";
        folderPreview.hidden = true;
        syncFolderMeta();
      };

      const clearSinglePreview = () => {
        singlePreviewUrls.forEach((url) => URL.revokeObjectURL(url));
        singlePreviewUrls = [];
        singlePreviewGrid.innerHTML = "";
        singlePreview.hidden = true;
        syncFolderMeta();
      };

      const renderFolderPreview = () => {
        clearFolderPreview();
        if (folderFiles.length === 0) return;
        const fragment = document.createDocumentFragment();
        folderFiles.forEach((file, index) => {
          const item = document.createElement("article");
          item.className = "preview-item";
          item.dataset.index = index;
          
          // åˆ é™¤æŒ‰é’®
          const deleteBtn = document.createElement("button");
          deleteBtn.className = "preview-delete";
          deleteBtn.innerHTML = "âœ•";
          deleteBtn.title = "åˆ é™¤æ­¤å›¾ç‰‡";
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            removeFolderFile(index);
          };
          
          const img = document.createElement("img");
          img.className = "preview-thumb";
          img.alt = `é¢„è§ˆå›¾ ${index + 1}`;
          img.loading = "lazy";
          const objectUrl = URL.createObjectURL(file);
          previewObjectUrls.push(objectUrl);
          img.src = objectUrl;
          const caption = document.createElement("p");
          caption.className = "preview-caption";
          caption.textContent = file.name;
          item.appendChild(deleteBtn);
          item.appendChild(img);
          item.appendChild(caption);
          fragment.appendChild(item);
        });
        folderPreviewGrid.appendChild(fragment);
        folderPreview.hidden = false;
        syncFolderMeta();
      };

      // åˆ é™¤æ–‡ä»¶å¤¹ä¸­çš„å•ä¸ªæ–‡ä»¶
      const removeFolderFile = (index) => {
        if (previewObjectUrls[index]) {
          URL.revokeObjectURL(previewObjectUrls[index]);
        }
        folderFiles.splice(index, 1);
        previewObjectUrls.splice(index, 1);
        if (folderFiles.length === 0) {
          clearFolderPreview();
          setStatus("å·²æ¸…ç©ºæ‰€æœ‰å›¾ç‰‡ã€‚");
        } else {
          renderFolderPreview();
          setStatus(`å·²é€‰æ‹© ${folderFiles.length} å¼ å›¾åƒï¼Œå°†æŒ‰é¡ºåºå¤„ç†ã€‚`);
        }
      };

      const renderSinglePreview = (file) => {
        clearSinglePreview();
        if (!file) return;
        const item = document.createElement("article");
        item.className = "preview-item";
        
        // åˆ é™¤æŒ‰é’®
        const deleteBtn = document.createElement("button");
        deleteBtn.className = "preview-delete";
        deleteBtn.innerHTML = "âœ•";
        deleteBtn.title = "åˆ é™¤æ­¤å›¾ç‰‡";
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          removeSingleFile();
        };
        
        const img = document.createElement("img");
        img.className = "preview-thumb";
        img.alt = "å•å›¾é¢„è§ˆ";
        img.loading = "lazy";
        const objectUrl = URL.createObjectURL(file);
        singlePreviewUrls.push(objectUrl);
        img.src = objectUrl;
        const caption = document.createElement("p");
        caption.className = "preview-caption";
        caption.textContent = file.name;
        item.appendChild(deleteBtn);
        item.appendChild(img);
        item.appendChild(caption);
        singlePreviewGrid.appendChild(item);
        singlePreview.hidden = false;
        syncFolderMeta();
      };

      // åˆ é™¤å•å¼ å›¾ç‰‡
      const removeSingleFile = () => {
        singleFileInput.value = "";
        clearSinglePreview();
        setStatus("å·²åˆ é™¤å›¾ç‰‡ã€‚");
      };

      // æ–‡ä»¶ä¸Šä¼ äº‹ä»¶
      folderInput.addEventListener("change", () => {
        folderFiles = Array.from(folderInput.files || []).filter((file) => file.type.startsWith("image/"));
        folderFiles.sort((a, b) => {
          const pathA = a.webkitRelativePath || a.name;
          const pathB = b.webkitRelativePath || b.name;
          return pathA.localeCompare(pathB, "zh-CN");
        });
        if (folderFiles.length === 0) {
          setStatus("æ‰€é€‰æ–‡ä»¶å¤¹ä¸­æœªæ‰¾åˆ°å›¾åƒæ–‡ä»¶ã€‚", 'error');
          clearFolderPreview();
          return;
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰æœªå®Œæˆçš„ä»»åŠ¡
        if (batchTaskState.hasPending() && batchTaskState.matchFiles(folderFiles)) {
          showResumePrompt(batchTaskState, 
            (state) => {
              // ç»§ç»­å¤„ç† - è¿‡æ»¤å‡ºæœªå®Œæˆçš„æ–‡ä»¶
              folderFiles = batchTaskState.filterPending(folderFiles);
              setStatus(`ç»§ç»­å¤„ç†å‰©ä½™ ${folderFiles.length} å¼ å›¾åƒã€‚`);
              renderFolderPreview();
            },
            () => {
              // é‡æ–°å¼€å§‹
              setStatus(`å·²é€‰æ‹© ${folderFiles.length} å¼ å›¾åƒï¼Œå°†æŒ‰é¡ºåºå¤„ç†ã€‚`);
              renderFolderPreview();
            }
          );
        } else {
          setStatus(`å·²é€‰æ‹© ${folderFiles.length} å¼ å›¾åƒï¼Œå°†æŒ‰é¡ºåºå¤„ç†ã€‚`);
          renderFolderPreview();
        }
      });

      singleFileInput.addEventListener("change", () => {
        const [file] = Array.from(singleFileInput.files || []);
        if (!file) { clearSinglePreview(); return; }
        if (!file.type || !file.type.startsWith("image/")) {
          setStatus("æ‰€é€‰æ–‡ä»¶ä¸æ˜¯å›¾åƒï¼Œè¯·é‡æ–°é€‰æ‹©ã€‚", 'error');
          singleFileInput.value = "";
          clearSinglePreview();
          return;
        }
        renderSinglePreview(file);
        setStatus("å·²é€‰æ‹©å•å¼ å›¾åƒï¼Œå°†åŒ…å«åœ¨è¯·æ±‚ä¸­ã€‚");
      });

      // æ‹–æ‹½ä¸Šä¼ 
      uploadZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadZone.classList.add("dragover");
      });
      uploadZone.addEventListener("dragleave", () => {
        uploadZone.classList.remove("dragover");
      });
      uploadZone.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadZone.classList.remove("dragover");
        const files = e.dataTransfer.files;
        if (files.length > 0 && files[0].type.startsWith("image/")) {
          singleFileInput.files = files;
          renderSinglePreview(files[0]);
          setStatus("å·²é€‰æ‹©å•å¼ å›¾åƒï¼Œå°†åŒ…å«åœ¨è¯·æ±‚ä¸­ã€‚");
        }
      });

      // ç²˜è´´å›¾ç‰‡æ”¯æŒ
      document.addEventListener("paste", (e) => {
        const items = e.clipboardData?.items;
        if (!items) return;
        for (const item of items) {
          if (item.type.startsWith("image/")) {
            const file = item.getAsFile();
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            singleFileInput.files = dataTransfer.files;
            renderSinglePreview(file);
            setStatus("å·²ç²˜è´´å›¾åƒï¼Œå°†åŒ…å«åœ¨è¯·æ±‚ä¸­ã€‚");
            break;
          }
        }
      });

      // æš‚åœå¤„ç†
      pauseButton.addEventListener("click", () => {
        if (!pauseButton.disabled) {
          isPaused = true;
          pauseButton.disabled = true;
          setStatus("å·²æš‚åœåç»­å¤„ç†ã€‚");
        }
      });

      // æ¨¡å‹åˆ‡æ¢
      const updateModelHint = () => {
        const selected = modelRegistry[modelSelect.value];
        if (!selected) return;
        const shouldShowResolution = Boolean(selected.supportsResolution);
        resolutionGroup.classList.toggle("hidden", !shouldShowResolution);
        if (shouldShowResolution) resolutionSelect.value = "1024";
        syncFormState();
      };
      modelSelect.addEventListener("change", updateModelHint);

      // æ¯”ä¾‹æŒ‰é’®åˆ‡æ¢
      const ratioBtns = document.querySelectorAll(".ratio-btn");
      const aspectRatioInput = document.getElementById("aspect-ratio");
      ratioBtns.forEach(btn => {
        btn.addEventListener("click", () => {
          ratioBtns.forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          aspectRatioInput.value = btn.dataset.ratio;
          syncFormState();
        });
      });

      resolutionSelect.addEventListener("change", () => {
        syncFormState();
      });

      autoOptimizeToggle.addEventListener("change", () => {
        syncFormState();
      });

      singleOptimizeToggle.addEventListener("change", () => {
        syncFormState();
      });

      // ä»»åŠ¡å†å²æ¸²æŸ“
      const renderHistory = () => {
        taskHistory = pruneHistory(taskHistory);
        if (taskHistory.length === 0) {
          historyEmptyState.hidden = false;
          taskHistoryList.innerHTML = "";
          downloadAllBtn.disabled = true;
          return;
        }
        historyEmptyState.hidden = true;
        taskHistoryList.innerHTML = taskHistory.map((entry, index) => {
          const position = taskHistory.length - index;
          const headerTitle = `ä»»åŠ¡ #${position}`;
          const createdAt = entry.createdAt instanceof Date ? entry.createdAt : new Date(entry.createdAt);
          const metaLines = [
            `<span><strong>æ—¶é—´ï¼š</strong>${formatDate(createdAt)}</span>`,
            `<span><strong>æç¤ºè¯ï¼š</strong>${escapeHtml((entry.prompt || "(ç©º)").substring(0, 30))}...</span>`,
          ];
          if (entry.fileName) {
            metaLines.push(`<span><strong>æºæ–‡ä»¶ï¼š</strong>${escapeHtml(entry.fileName)}</span>`);
          }
          const imageContent = entry.images.length
            ? entry.images.map((image, imageIndex) => {
                const href = buildImageHref(image);
                const extension = getExtensionFromMime(image.mimeType);
                const preview = image.data ? href : image.url;
                return `
                  <article class="history-image">
                    <img src="${preview}" alt="ä»»åŠ¡å›¾åƒé¢„è§ˆ" loading="lazy" />
                    <div class="history-actions">
                      <button type="button" data-role="download-image" data-task="${entry.id}" data-index="${imageIndex}">
                        ä¸‹è½½ (${extension.toUpperCase()})
                      </button>
                    </div>
                  </article>
                `;
              }).join("")
            : `<p class="helper">æœ¬æ¬¡å“åº”æ²¡æœ‰å›¾åƒè¾“å‡ºã€‚</p>`;
          return `
            <article class="history-item" data-task="${entry.id}">
              <header>
                <div class="history-meta">
                  <strong>${headerTitle}</strong>
                  ${metaLines.join("")}
                </div>
                <div class="history-actions">
                  <button type="button" data-role="download-task" data-task="${entry.id}" ${entry.images.length === 0 ? "disabled" : ""}>
                    ä¸‹è½½è¯¥é¡¹ (${entry.images.length})
                  </button>
                  <button type="button" data-role="delete-task" data-task="${entry.id}" style="margin-left: 8px; color: #ef4444;">
                    åˆ é™¤
                  </button>
                </div>
              </header>
              <div class="history-image-grid">${imageContent}</div>
            </article>
          `;
        }).join("");
        const hasImages = taskHistory.some((entry) => entry.images.length > 0);
        downloadAllBtn.disabled = !hasImages;
      };

      // æ‰¹é‡è®°å½•ä»»åŠ¡çš„ç¼“å†²åŒº
      let pendingTasks = [];
      let recordTaskTimer = null;
      const RECORD_BATCH_DELAY = 500; // 500ms å†…çš„ä»»åŠ¡åˆå¹¶å¤„ç†

      const flushPendingTasks = async () => {
        if (pendingTasks.length === 0) return;
        
        const tasksToProcess = pendingTasks.slice();
        pendingTasks = [];
        
        // åˆå¹¶ä¸ºä¸€ä¸ªä»»åŠ¡è®°å½•ï¼ˆå¤šæ¬¡æ‰§è¡Œåˆå¹¶ä¸ºä¸€æ¡ï¼‰
        const mergedImages = tasksToProcess.flatMap(t => t.images || []);
        const firstTask = tasksToProcess[0];
        
        // é™åˆ¶å•æ¡è®°å½•æœ€å¤šä¿å­˜ 20 å¼ å›¾ç‰‡
        const limitedImages = mergedImages.slice(0, 20);
        
        const entry = {
          id: `task-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
          createdAt: new Date(),
          prompt: firstTask.prompt,
          fileName: firstTask.fileName,
          images: limitedImages,
          totalCount: mergedImages.length
        };
        
        taskHistory.unshift(entry);
        taskHistory = pruneHistory(taskHistory);
        renderHistory();
        
        // ä¿å­˜åˆ° IndexedDB
        try {
          await HistoryDB.saveTask(PAGE_KEY, entry);
        } catch (e) {
          console.warn('ä¿å­˜ä»»åŠ¡åˆ°æ•°æ®åº“å¤±è´¥:', e);
        }
        
        // ä¿å­˜åˆ°ä¸ªäººç©ºé—´ï¼ˆåªä¿å­˜å‰ 10 å¼ ï¼‰
        const apiKey = credentialInput.value.trim();
        if (apiKey && mergedImages.length > 0 && typeof DuuStorage !== 'undefined') {
          mergedImages.slice(0, 10).forEach((img, idx) => {
            const imageData = img.url || `data:${img.mimeType || 'image/png'};base64,${img.data}`;
            const title = firstTask.prompt ? `${firstTask.prompt.substring(0, 20)}...` : `æå–å°èŠ±_${idx + 1}`;
            DuuStorage.saveImage(apiKey, imageData, title, 'æå–å°èŠ±').catch(console.error);
          });
        }
      };

      const recordTask = async ({ prompt, fileName, images, execIndex }) => {
        // å¦‚æœæ˜¯æ‰¹é‡æ‰§è¡Œçš„ä¸€éƒ¨åˆ†ï¼ŒåŠ å…¥ç¼“å†²åŒº
        if (execIndex !== undefined) {
          pendingTasks.push({ prompt, fileName, images, execIndex });
          
          // é˜²æŠ–ï¼šå»¶è¿Ÿå¤„ç†
          if (recordTaskTimer) clearTimeout(recordTaskTimer);
          recordTaskTimer = setTimeout(flushPendingTasks, RECORD_BATCH_DELAY);
          return;
        }
        
        // å•æ¬¡æ‰§è¡Œï¼Œç›´æ¥è®°å½•
        const entry = {
          id: `task-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
          createdAt: new Date(),
          prompt,
          fileName,
          images: (images || []).slice(0, 10),
        };
        taskHistory.unshift(entry);
        taskHistory = pruneHistory(taskHistory);
        renderHistory();
        
        // ä¿å­˜åˆ° IndexedDB
        try {
          await HistoryDB.saveTask(PAGE_KEY, entry);
        } catch (e) {
          console.warn('ä¿å­˜ä»»åŠ¡åˆ°æ•°æ®åº“å¤±è´¥:', e);
        }
        
        // ä¿å­˜åˆ°æœåŠ¡å™¨
        const apiKey = credentialInput.value.trim();
        if (apiKey && images && images.length > 0) {
          try {
            const serverImages = images.slice(0, 10).map(img => {
              if (img.data && img.mimeType) {
                return { base64: `data:${img.mimeType};base64,${img.data}` };
              }
              if (img.url) {
                return { url: img.url };
              }
              return img;
            });
            await ImageServer.saveGeneration(apiKey, prompt, serverImages, 'gemini-extract', 'image');
          } catch (e) {
            console.warn('ä¿å­˜åˆ°æœåŠ¡å™¨å¤±è´¥:', e);
          }
        }
      };

      // ä¸‹è½½åŠŸèƒ½
      const triggerDownload = (href, filename) => {
        const link = document.createElement("a");
        link.href = href;
        link.download = filename;
        link.rel = "noopener";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      };

      const downloadImages = (images = [], prefix = "task") => {
        images.forEach((image, index) => {
          const extension = getExtensionFromMime(image.mimeType);
          const filename = `${prefix}-${String(index + 1).padStart(2, "0")}.${extension}`;
          const href = buildImageHref(image);
          setTimeout(() => triggerDownload(href, filename), index * 150);
        });
      };

      downloadAllBtn.addEventListener("click", () => {
        const downloadables = taskHistory.flatMap((entry, entryIndex) =>
          entry.images.map((image, imageIndex) => ({
            href: buildImageHref(image),
            filename: `${entry.id}-${String(imageIndex + 1).padStart(2, "0")}.${getExtensionFromMime(image.mimeType)}`,
            order: entryIndex * 100 + imageIndex,
          }))
        );
        if (downloadables.length === 0) {
          setStatus("æš‚æ— å¯ä¸‹è½½çš„å›¾åƒã€‚", '', { skipCache: true });
          return;
        }
        downloadables.sort((a, b) => a.order - b.order).forEach((item, index) => {
          setTimeout(() => triggerDownload(item.href, item.filename), index * 180);
        });
        setStatus(`å·²å¼€å§‹ä¸‹è½½ ${downloadables.length} å¼ å›¾åƒã€‚`, 'success', { skipCache: true });
      });

      // å›¾ç‰‡é¢„è§ˆå¼¹çª—åŠŸèƒ½
      const previewModal = document.getElementById('imagePreviewModal');
      const previewImage = document.getElementById('previewImage');
      const previewClose = document.getElementById('previewClose');
      const previewDownload = document.getElementById('previewDownload');
      let currentPreviewSrc = '';

      const showImagePreview = (src) => {
        currentPreviewSrc = src;
        previewImage.src = src;
        previewModal.classList.add('active');
        document.body.style.overflow = 'hidden';
      };

      const hideImagePreview = () => {
        previewModal.classList.remove('active');
        document.body.style.overflow = '';
        previewImage.src = '';
        currentPreviewSrc = '';
      };

      previewClose.addEventListener('click', hideImagePreview);
      previewModal.addEventListener('click', (e) => {
        if (e.target === previewModal) hideImagePreview();
      });
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && previewModal.classList.contains('active')) {
          hideImagePreview();
        }
      });
      previewDownload.addEventListener('click', () => {
        if (currentPreviewSrc) {
          const filename = `preview-${Date.now()}.png`;
          triggerDownload(currentPreviewSrc, filename);
        }
      });

      taskHistoryList.addEventListener("click", (event) => {
        // ç‚¹å‡»å›¾ç‰‡é¢„è§ˆå¤§å›¾
        const img = event.target.closest('.history-image img');
        if (img) {
          showImagePreview(img.src);
          return;
        }

        const button = event.target.closest("button[data-role]");
        if (!button) return;
        const taskId = button.getAttribute("data-task");
        const entry = taskHistory.find((item) => item.id === taskId);
        if (!entry) return;
        if (button.dataset.role === "download-task") {
          downloadImages(entry.images, entry.id);
          return;
        }
        if (button.dataset.role === "download-image") {
          const imageIndex = Number(button.getAttribute("data-index"));
          const image = entry.images[imageIndex];
          if (!image) return;
          const extension = getExtensionFromMime(image.mimeType);
          const filename = `${entry.id}-${String(imageIndex + 1).padStart(2, "0")}.${extension}`;
          triggerDownload(buildImageHref(image), filename);
        }
        if (button.dataset.role === "delete-task") {
          if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä»»åŠ¡å—ï¼Ÿ')) {
            taskHistory = taskHistory.filter((item) => item.id !== taskId);
            renderHistory();
            // ä»æ•°æ®åº“åˆ é™¤
            HistoryDB.deleteTask(taskId).catch(console.warn);
          }
        }
      });
      const buildRequestBody = async (overrideFile = null, modelConfig = modelRegistry[modelSelect.value], customPrompt = null) => {
        const prompt = customPrompt || BUILT_IN_PROMPT;
        const imageFile = overrideFile ?? singleFileInput.files[0];
        const responseModalities = document.getElementById("response-modalities").value.split(",");
        const aspectRatio = document.getElementById("aspect-ratio").value;
        const supportsResolution = Boolean(modelConfig?.supportsResolution);

        const parts = [{ text: prompt }];

        if (imageFile) {
          const { base64, mimeType } = await readFileAsBase64(imageFile);
          parts.push({
            inline_data: {
              mime_type: mimeType || "image/jpeg",
              data: base64,
            },
          });
        }

        const generationConfig = {
          responseModalities,
          imageConfig: { aspectRatio },
        };

        if (supportsResolution) {
          generationConfig.imageConfig.targetResolution = Number(resolutionSelect.value);
        }

        return {
          contents: [{ role: "user", parts }],
          generationConfig,
        };
      };

      // æ‰§è¡ŒAPIè¯·æ±‚ï¼ˆæ”¯æŒè‡ªåŠ¨åˆ‡æ¢å¤‡ç”¨Keyï¼‰
      const executeRequest = async (body, apiKey, bearerToken, modelConfig) => {
        const doRequest = async (key) => {
          const endpoint = (modelConfig && modelConfig.endpoint(key)) || modelRegistry["gemini-2.5-flash-image"].endpoint(key);

          let response;
          try {
            response = await fetch(endpoint, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${key}`,
              },
              body: JSON.stringify(body),
            });
          } catch (fetchError) {
            // ç½‘ç»œé”™è¯¯æˆ–CORSé”™è¯¯
            console.error('Fetché”™è¯¯:', fetchError);
            throw new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼š${fetchError.message}\n\nå¯èƒ½åŸå› ï¼š\n1. ç½‘ç»œè¿æ¥é—®é¢˜\n2. APIæœåŠ¡å™¨æ— æ³•è®¿é—®\n3. æµè§ˆå™¨CORSé™åˆ¶\n4. è¯·ç¡®ä¿é€šè¿‡HTTPæœåŠ¡å™¨è¿è¡Œæ­¤é¡µé¢ï¼ˆä¸è¦ç”¨file://åè®®ï¼‰`);
          }

          const responseText = await response.text();

          if (!response.ok) {
            throw new Error(`${response.status} ${response.statusText}\n${responseText}`);
          }

          let json;
          try {
            json = JSON.parse(responseText);
          } catch (error) {
            throw new Error("å“åº”å·²è¿”å›ï¼Œä½†è§£æ JSON å¤±è´¥ã€‚");
          }

          return { json, responseText };
        };

        // è·å–å¤‡ç”¨Key
        const backupKey = window.DuuApiKeys ? window.DuuApiKeys.getBackup('gemini') : '';

        try {
          return await doRequest(apiKey);
        } catch (error) {
          const errorMsg = error.message || '';
          // åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ‡æ¢Key
          if (backupKey && backupKey !== apiKey && window.shouldRetryWithBackup && window.shouldRetryWithBackup(errorMsg)) {
            console.log('é¦–é€‰Keyå¤±è´¥ï¼Œå°è¯•å¤‡ç”¨Key...', errorMsg);
            setStatus('é¦–é€‰Keyä¸å¯ç”¨ï¼Œæ­£åœ¨å°è¯•å¤‡ç”¨Key...');
            return await doRequest(backupKey);
          }
          throw error;
        }
      };

      // æ¸²æŸ“è¾“å‡º
      const renderTextOutputs = (candidates = []) => {
        const texts = [];
        candidates.forEach((candidate) => {
          candidate.content?.parts?.forEach((part) => {
            if (part.text) texts.push(part.text);
          });
        });
        if (texts.length === 0) {
          textOutput.hidden = true;
          textOutput.innerHTML = "";
          if (imageOutput.hidden) {
            outputSection.hidden = true;
          }
          mergeTaskState({
            output: {
              texts: [],
            },
          });
          return [];
        }
        textOutput.hidden = false;
        textOutput.innerHTML = texts.map((paragraph) =>
          `<article style="padding:16px;border-radius:12px;background:#f8f9fb;border:1px solid #e8ecf1;line-height:1.7;margin-top:12px;">${paragraph.replace(/\r?\n/g, "<br />")}</article>`
        ).join("");
        outputSection.hidden = false;
        mergeTaskState({
          output: {
            texts,
          },
        });
        return texts;
      };

      const renderImageOutputs = (candidates = []) => {
        const images = [];
        candidates.forEach((candidate) => {
          candidate.content?.parts?.forEach((part) => {
            const inlineData = part.inline_data ?? (part.inlineData ? { mime_type: part.inlineData.mimeType, data: part.inlineData.data } : null);
            if (inlineData?.mime_type && inlineData?.data) {
              images.push({ mimeType: inlineData.mime_type, data: inlineData.data });
            }
            if (part.file_data?.file_uri) {
              images.push({ mimeType: "image/*", url: part.file_data.file_uri });
            }
          });
        });
        if (images.length === 0) {
          imageOutput.innerHTML = "";
          imageOutput.hidden = true;
          if (textOutput.hidden) {
            outputSection.hidden = true;
          }
          mergeTaskState({
            output: {
              images: [],
            },
          });
          return [];
        }
        outputSection.hidden = false;
        imageOutput.hidden = false;
        imageOutput.innerHTML = images.map(({ mimeType, data, url }) => {
          const src = url || `data:${mimeType};base64,${data}`;
          return `<figure><img src="${src}" alt="ç”Ÿæˆå›¾åƒ" /><figcaption>${mimeType}</figcaption></figure>`;
        }).join("");
        mergeTaskState({
          output: {
            images,
          },
        });
        return images;
      };

      // ä¸»æäº¤å¤„ç†
      submitBtn.addEventListener("click", async () => {
        try {
          toggleLoading(true);
          imageOutput.innerHTML = "";
          textOutput.innerHTML = "";
          imageOutput.hidden = true;
          textOutput.hidden = true;
          outputSection.hidden = true;
          setStatus('', '', { skipCache: true });
          mergeTaskState({ output: null });

          const credential = credentialInput.value.trim();
          if (!credential) {
            setStatus("è¯·ç²˜è´´è®¿é—®å‡­è¯ã€‚", 'error');
            toggleLoading(false);
            return;
          }

          const selectedModel = modelRegistry[modelSelect.value] || modelRegistry["gemini-2.5-flash-image"];
          const mode = getUploadMode();
          isPaused = false;

          syncFormState();
          syncFolderMeta();

          if (mode === "folder") {
            if (folderFiles.length === 0) {
              setStatus("è¯·å…ˆé€‰æ‹©åŒ…å«å›¾åƒçš„æ–‡ä»¶å¤¹ã€‚", 'error');
              toggleLoading(false);
              return;
            }

            const enableAutoOptimize = autoOptimizeToggle.checked;
            const concurrentSelect = document.getElementById('concurrent-limit');
            const maxConcurrent = parseInt(concurrentSelect?.value || '20', 10);

            // åˆå§‹åŒ–è¿›åº¦æ¡
            const progressBar = new ProgressBar('batch-progress-container');
            progressBar.show();
            progressBar.reset();

            // æ–‡ä»¶ååˆ°æ–‡ä»¶å¯¹è±¡çš„æ˜ å°„ï¼ˆç”¨äºé‡è¯•ï¼‰
            const fileMap = {};
            folderFiles.forEach(f => fileMap[f.name] = f);

            // å‡†å¤‡ä»»åŠ¡åˆ—è¡¨ - ä¸Šä¼ å¤šå°‘å¼ å°±å¹¶å‘å¤„ç†å¤šå°‘å¼ 
            const tasks = folderFiles.map((file) => ({
              fileName: file.name,
              execute: async () => {
                let currentPrompt = BUILT_IN_PROMPT;

                // å¦‚æœå¯ç”¨äº†æç¤ºè¯ä¼˜åŒ–
                if (enableAutoOptimize) {
                  try {
                    currentPrompt = await optimizePromptForImage(file, credential);
                  } catch (optError) {
                    console.warn(`å›¾ç‰‡ ${file.name} æç¤ºè¯ä¼˜åŒ–å¤±è´¥ï¼Œä½¿ç”¨å†…ç½®æç¤ºè¯:`, optError);
                  }
                }

                const body = await buildRequestBody(file, selectedModel, enableAutoOptimize ? currentPrompt : null);
                const { json } = await executeRequest(body, credential, credential, selectedModel);
                const candidates = json.candidates || [];
                const images = renderImageOutputs(candidates);
                
                return { prompt: currentPrompt, fileName: file.name, images: images || [] };
              }
            }));

            // æ”¶é›†å¤±è´¥æ–‡ä»¶ä¿¡æ¯
            const failedItems = [];
            
            // é‡è¯•å¤±è´¥é¡¹çš„å‡½æ•°
            const retryFailedItems = async (items) => {
              if (items.length === 0) return;
              
              progressBar.reset();
              progressBar.show();
              failedItems.length = 0; // æ¸…ç©º
              
              const retryTasks = items.map(item => {
                // ä¼˜å…ˆä½¿ç”¨ä¿å­˜çš„æ–‡ä»¶å¯¹è±¡ï¼Œå…¶æ¬¡ä»fileMapè·å–
                const file = item.file || fileMap[item.fileName];
                if (!file) {
                  console.warn(`é‡è¯•å¤±è´¥ï¼šæ‰¾ä¸åˆ°æ–‡ä»¶ ${item.fileName}`);
                  return null;
                }
                return {
                  fileName: file.name,
                  execute: async () => {
                    let currentPrompt = BUILT_IN_PROMPT;
                    if (enableAutoOptimize) {
                      try {
                        currentPrompt = await optimizePromptForImage(file, credential);
                      } catch (optError) {
                        console.warn(`å›¾ç‰‡ ${file.name} æç¤ºè¯ä¼˜åŒ–å¤±è´¥:`, optError);
                      }
                    }
                    const body = await buildRequestBody(file, selectedModel, enableAutoOptimize ? currentPrompt : null);
                    const { json } = await executeRequest(body, credential, credential, selectedModel);
                    const candidates = json.candidates || [];
                    const images = renderImageOutputs(candidates);
                    return { prompt: currentPrompt, fileName: file.name, images: images || [] };
                  }
                };
              }).filter(Boolean);
              
              if (retryTasks.length === 0) {
                setStatus('æ²¡æœ‰å¯é‡è¯•çš„æ–‡ä»¶ï¼Œæ–‡ä»¶å¯¹è±¡å¯èƒ½å·²ä¸¢å¤±', 'error');
                return;
              }
              
              const retryProcessor = new BatchProcessor({
                maxConcurrent,
                onProgress: (progress) => {
                  progressBar.update(progress);
                  setStatus(`é‡è¯•ä¸­: ${progress.fileName} (${progress.completed}/${progress.total})`, '', { skipCache: true });
                },
                onTaskComplete: ({ success, result }) => {
                  if (success && result) recordTask(result);
                },
                onError: ({ error, fileName }) => {
                  const errMsg = error?.message || error?.toString() || 'è¯·æ±‚å¤±è´¥';
                  // é‡è¯•å¤±è´¥æ—¶ä¹Ÿä¿å­˜æ–‡ä»¶å¯¹è±¡
                  const file = items.find(i => i.fileName === fileName)?.file || fileMap[fileName];
                  failedItems.push({ 
                    fileName, 
                    error: errMsg.length > 30 ? errMsg.substring(0, 30) + '...' : errMsg,
                    file
                  });
                },
                onComplete: (summary) => {
                  progressBar.complete(summary, failedItems);
                  if (summary.failed === 0) {
                    setStatus(`é‡è¯•å®Œæˆï¼Œå…¨éƒ¨æˆåŠŸï¼`, 'success');
                  } else {
                    setStatus(`é‡è¯•ç»“æŸï¼ŒæˆåŠŸ ${summary.succeeded} å¼ ï¼Œä»æœ‰ ${summary.failed} å¼ å¤±è´¥ã€‚`, 'warning');
                  }
                }
              });
              
              await retryProcessor.process(retryTasks);
            };
            
            // è®¾ç½®é‡è¯•å›è°ƒ
            progressBar.onRetry = retryFailedItems;
            
            // ä¿å­˜åˆå§‹ä»»åŠ¡çŠ¶æ€ï¼ˆç”¨äºæ–­ç‚¹ç»­ä¼ ï¼‰
            batchTaskState.save({
              pendingFiles: folderFiles.map(f => ({ name: f.name, size: f.size, lastModified: f.lastModified })),
              completedFiles: [],
              failedFiles: [],
              options: { model: selectedModel.model, enableAutoOptimize }
            });
            
            // åˆ›å»ºæ‰¹é‡å¤„ç†å™¨
            const batchProcessor = new BatchProcessor({
              maxConcurrent,
              onProgress: (progress) => {
                progressBar.update(progress);
                setStatus(`æ­£åœ¨å¤„ç†: ${progress.fileName} (${progress.completed}/${progress.total})`, '', { skipCache: true });
              },
              onTaskComplete: ({ success, result, fileName }) => {
                if (success && result) {
                  recordTask(result);
                  batchTaskState.markCompleted(fileName);
                }
              },
              onError: ({ error, fileName }) => {
                console.error(`å¤„ç† ${fileName} å¤±è´¥:`, error);
                // æ”¶é›†å¤±è´¥ä¿¡æ¯ï¼Œä¿å­˜æ–‡ä»¶å¯¹è±¡ç”¨äºé‡è¯•
                const errMsg = error?.message || error?.toString() || 'è¯·æ±‚å¤±è´¥';
                failedItems.push({ 
                  fileName, 
                  error: errMsg.length > 30 ? errMsg.substring(0, 30) + '...' : errMsg,
                  file: fileMap[fileName]
                });
                batchTaskState.markFailed(fileName, errMsg);
              },
              onComplete: (summary) => {
                progressBar.complete(summary, failedItems);
                // å…¨éƒ¨å®Œæˆåæ¸…é™¤æ–­ç‚¹ç»­ä¼ çŠ¶æ€
                if (summary.failed === 0) {
                  batchTaskState.clear();
                  setStatus(`å¤„ç†å®Œæˆï¼Œå…±å®Œæˆ ${summary.succeeded} å¼ å›¾åƒã€‚`, 'success');
                } else if (summary.succeeded === 0) {
                  setStatus(`å¤„ç†ç»“æŸï¼Œ${summary.failed} å¼ å…¨éƒ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥åé‡è¯•ã€‚`, 'error');
                } else {
                  setStatus(`å¤„ç†ç»“æŸï¼ŒæˆåŠŸ ${summary.succeeded} å¼ ï¼Œå¤±è´¥ ${summary.failed} å¼ ã€‚`, 'warning');
                }
              }
            });

            // ç»‘å®šæš‚åœæŒ‰é’®
            pauseButton.disabled = false;
            pauseButton.textContent = 'æš‚åœå¤„ç†';
            const pauseHandler = () => {
              if (batchProcessor.isPaused()) {
                batchProcessor.resume();
                pauseButton.textContent = 'æš‚åœå¤„ç†';
                setStatus('å·²æ¢å¤å¤„ç†...', '', { skipCache: true });
              } else {
                batchProcessor.pause();
                pauseButton.textContent = 'ç»§ç»­å¤„ç†';
                setStatus('å·²æš‚åœï¼Œç‚¹å‡»ç»§ç»­å¤„ç†', 'warning', { skipCache: true });
              }
            };
            pauseButton.onclick = pauseHandler;

            // æ‰§è¡Œæ‰¹é‡å¤„ç†
            await batchProcessor.process(tasks);
            pauseButton.disabled = true;
            pauseButton.textContent = 'æš‚åœå¤„ç†';
            pauseButton.onclick = null;
          } else {
            // å•å¼ å›¾ç‰‡å¤„ç†
            const enableSingleOptimize = singleOptimizeToggle.checked;
            const imageFile = singleFileInput.files[0];
            const execCount = getSingleExecCount();

            if (execCount > 1) {
              // å¤šæ¬¡æ‰§è¡Œæ¨¡å¼ - å¹¶å‘å¤„ç†
              const progressBar = new ProgressBar('single-progress-container');
              progressBar.show();
              progressBar.reset();

              const tasks = [];
              for (let i = 0; i < execCount; i++) {
                tasks.push({
                  fileName: `ç¬¬ ${i + 1} æ¬¡`,
                  execute: async () => {
                    let currentPrompt = BUILT_IN_PROMPT;

                    // å¦‚æœå¯ç”¨äº†æç¤ºè¯ä¼˜åŒ–ï¼Œæ¯æ¬¡éƒ½æ‰§è¡Œ
                    if (enableSingleOptimize && imageFile) {
                      try {
                        currentPrompt = await optimizePromptForImage(imageFile, credential);
                      } catch (optError) {
                        console.warn("æç¤ºè¯ä¼˜åŒ–å¤±è´¥ï¼Œä½¿ç”¨å†…ç½®æç¤ºè¯:", optError);
                      }
                    }

                    const body = await buildRequestBody(null, selectedModel, enableSingleOptimize ? currentPrompt : null);
                    const { json } = await executeRequest(body, credential, credential, selectedModel);
                    const candidates = json.candidates || [];
                    const images = renderImageOutputs(candidates);
                    
                    return { prompt: currentPrompt, fileName: imageFile?.name || null, execIndex: i + 1, images: images || [] };
                  }
                });
              }

              // æ”¶é›†å¤±è´¥ä¿¡æ¯
              const singleFailedItems = [];
              
              const batchProcessor = new BatchProcessor({
                maxConcurrent: 20,
                onProgress: (progress) => {
                  progressBar.update(progress);
                  setStatus(`æ­£åœ¨æ‰§è¡Œ: ${progress.fileName} (${progress.completed}/${progress.total})`, '', { skipCache: true });
                },
                onTaskComplete: ({ success, result }) => {
                  if (success && result) {
                    recordTask(result);
                  }
                },
                onError: ({ error, fileName }) => {
                  console.error(`${fileName} æ‰§è¡Œå¤±è´¥:`, error);
                  const errMsg = error?.message || error?.toString() || 'è¯·æ±‚å¤±è´¥';
                  singleFailedItems.push({ fileName, error: errMsg.length > 30 ? errMsg.substring(0, 30) + '...' : errMsg });
                },
                onComplete: (summary) => {
                  progressBar.complete(summary, singleFailedItems);
                  // ç«‹å³åˆ·æ–°ç¼“å†²åŒºä¸­çš„ä»»åŠ¡
                  if (recordTaskTimer) clearTimeout(recordTaskTimer);
                  flushPendingTasks();
                  
                  if (summary.failed === 0) {
                    setStatus(`æ‰§è¡Œå®Œæˆï¼Œå…±å®Œæˆ ${summary.succeeded} æ¬¡ã€‚`, 'success');
                  } else if (summary.succeeded === 0) {
                    setStatus(`æ‰§è¡Œç»“æŸï¼Œ${summary.failed} æ¬¡å…¨éƒ¨å¤±è´¥ã€‚`, 'error');
                  } else {
                    setStatus(`æ‰§è¡Œç»“æŸï¼ŒæˆåŠŸ ${summary.succeeded} æ¬¡ï¼Œå¤±è´¥ ${summary.failed} æ¬¡ã€‚`, 'warning');
                  }
                }
              });

              await batchProcessor.process(tasks);
            } else {
              // å•æ¬¡æ‰§è¡Œæ¨¡å¼
              let currentPrompt = BUILT_IN_PROMPT;

              // å¦‚æœå¯ç”¨äº†æç¤ºè¯ä¼˜åŒ–
              if (enableSingleOptimize && imageFile) {
                setStatus("æ­£åœ¨åˆ†æå›¾ç‰‡ï¼Œä¼˜åŒ–æç¤ºè¯ä¸­...");
                try {
                  currentPrompt = await optimizePromptForImage(imageFile, credential);
                } catch (optError) {
                  console.warn("æç¤ºè¯ä¼˜åŒ–å¤±è´¥ï¼Œä½¿ç”¨å†…ç½®æç¤ºè¯:", optError);
                }
              }

              setStatus("æ­£åœ¨å¤„ç†å›¾ç‰‡...");

              const body = await buildRequestBody(null, selectedModel, enableSingleOptimize ? currentPrompt : null);
              const { json } = await executeRequest(body, credential, credential, selectedModel);
              const candidates = json.candidates || [];
              renderTextOutputs(candidates);
              const images = renderImageOutputs(candidates);
              recordTask({ prompt: currentPrompt, fileName: imageFile?.name || null, images: images || [] });
              setStatus("è¯·æ±‚æˆåŠŸï¼Œå·²æ¸²æŸ“ç»“æœã€‚", 'success');
            }
          }
        } catch (error) {
          console.error(error);
          setStatus(`è¯·æ±‚å¼‚å¸¸ï¼š${error.message}`, 'error');
        } finally {
          toggleLoading(false);
          pauseButton.disabled = true;
        }
      });

      const applyFolderMeta = (meta = {}) => {
        if (!meta) return;
        const mode = meta.mode || getUploadMode();
        const radio = document.querySelector(`input[name='upload-mode'][value='${mode}']`);
        if (radio && !radio.checked) {
          radio.checked = true;
        }
        updateUploadVisibility({ skipClear: true });

        if (mode === 'folder') {
          folderPreviewGrid.innerHTML = '';
          if (Array.isArray(meta.fileNames) && meta.fileNames.length) {
            const fragment = document.createDocumentFragment();
            meta.fileNames.forEach((name, index) => {
              const item = document.createElement('article');
              item.className = 'preview-item placeholder';
              item.innerHTML = `
                <div class="preview-thumb" style="display:flex;align-items:center;justify-content:center;font-size:12px;color:#94a3b8;background:#f1f5f9;border:1px dashed #cbd5f5;">æ— é¢„è§ˆ</div>
                <p class="preview-caption">${escapeHtml(name)}</p>
              `;
              fragment.appendChild(item);
            });
            folderPreviewGrid.appendChild(fragment);
            folderPreview.hidden = false;
          } else {
            folderPreview.hidden = true;
          }
          singlePreview.hidden = true;
          singlePreviewGrid.innerHTML = '';
        } else {
          folderPreview.hidden = true;
          folderPreviewGrid.innerHTML = '';
          if (meta.fileName) {
            singlePreview.hidden = false;
            singlePreviewGrid.innerHTML = `
              <article class="preview-item placeholder">
                <div class="preview-thumb" style="display:flex;align-items:center;justify-content:center;font-size:12px;color:#94a3b8;background:#f1f5f9;border:1px dashed #cbd5f5;">æ— é¢„è§ˆ</div>
                <p class="preview-caption">${escapeHtml(meta.fileName)}</p>
              </article>
            `;
          } else {
            singlePreview.hidden = true;
            singlePreviewGrid.innerHTML = '';
          }
        }
      };

      const restoreOutputs = (output = {}) => {
        const images = Array.isArray(output.images) ? output.images : [];
        const texts = Array.isArray(output.texts) ? output.texts : [];

        if (images.length > 0) {
          imageOutput.hidden = false;
          imageOutput.innerHTML = images.map(({ mimeType, data, url }) => {
            const src = url || `data:${mimeType};base64,${data}`;
            return `<figure><img src="${src}" alt="ç”Ÿæˆå›¾åƒ" /><figcaption>${mimeType}</figcaption></figure>`;
          }).join('');
        } else {
          imageOutput.hidden = true;
          imageOutput.innerHTML = '';
        }

        if (texts.length > 0) {
          textOutput.hidden = false;
          textOutput.innerHTML = texts.map((paragraph) =>
            `<article style="padding:16px;border-radius:12px;background:#f8f9fb;border:1px solid #e8ecf1;line-height:1.7;margin-top:12px;">${paragraph.replace(/\r?\n/g, "<br />")}</article>`
          ).join('');
        } else {
          textOutput.hidden = true;
          textOutput.innerHTML = '';
        }

        outputSection.hidden = images.length === 0 && texts.length === 0;
      };

      const restoreTaskState = () => {
        const state = readTaskState();
        if (!state) {
          updateUploadVisibility({ skipClear: true });
          updateModelHint();
          return;
        }

        isRestoring = true;

        if (state.form) {
          if (state.form.model && modelRegistry[state.form.model]) {
            modelSelect.value = state.form.model;
          }
          if (state.form.aspectRatio) {
            aspectRatioInput.value = state.form.aspectRatio;
            ratioBtns.forEach((btn) => {
              btn.classList.toggle('active', btn.dataset.ratio === state.form.aspectRatio);
            });
          }
          if (state.form.resolution) {
            resolutionSelect.value = state.form.resolution;
          }
          if (state.form.uploadMode) {
            const radio = document.querySelector(`input[name='upload-mode'][value='${state.form.uploadMode}']`);
            if (radio) {
              radio.checked = true;
            }
          }
          autoOptimizeToggle.checked = Boolean(state.form.autoOptimize);
          singleOptimizeToggle.checked = Boolean(state.form.singleOptimize);
        }

        updateModelHint();
        updateUploadVisibility({ skipClear: true });

        if (state.folderMeta) {
          applyFolderMeta(state.folderMeta);
        }

        if (state.status) {
          setStatus(state.status.message || '', state.status.type || '', { skipCache: true });
        }

        if (Array.isArray(state.history) && state.history.length) {
          taskHistory = restoreHistoryFromStorage(state.history);
          renderHistory();
        }

        if (state.output) {
          restoreOutputs(state.output);
        }

        isRestoring = false;
        syncFormState();
        syncFolderMeta();
      };

      // åˆå§‹åŒ–
      updateUploadVisibility({ skipClear: true });
      updateModelHint();
      renderHistory();
      restoreTaskState();
    </script>
</body>
</html>